// Generated by CIRCT firtool-1.62.0
// VCS coverage exclude_file
module ram_32x8(
  input  [4:0] R0_addr,
  input        R0_en,
               R0_clk,
  output [7:0] R0_data,
  input  [4:0] W0_addr,
  input        W0_en,
               W0_clk,
  input  [7:0] W0_data
);

  reg [7:0] Memory[0:31];
  reg       _R0_en_d0;
  reg [4:0] _R0_addr_d0;
  always @(posedge R0_clk) begin
    _R0_en_d0 <= R0_en;
    _R0_addr_d0 <= R0_addr;
  end // always @(posedge)
  always @(posedge W0_clk) begin
    if (W0_en & 1'h1)
      Memory[W0_addr] <= W0_data;
  end // always @(posedge)
  assign R0_data = _R0_en_d0 ? Memory[_R0_addr_d0] : 8'bx;
endmodule

module Queue32_UInt8(
  input        clock,
               reset,
               io_enq_valid,
  input  [7:0] io_enq_bits,
  input        io_deq_ready,
  output       io_deq_valid,
  output [7:0] io_deq_bits
);

  wire       io_enq_ready;
  reg  [4:0] enq_ptr_value;
  reg  [4:0] deq_ptr_value;
  reg        maybe_full;
  wire       ptr_match = enq_ptr_value == deq_ptr_value;
  wire       empty = ptr_match & ~maybe_full;
  wire       do_enq = io_enq_ready & io_enq_valid;
  wire       do_deq = io_deq_ready & ~empty;
  assign io_enq_ready = io_deq_ready | ~(ptr_match & maybe_full);
  always @(posedge clock) begin
    if (reset) begin
      enq_ptr_value <= 5'h0;
      deq_ptr_value <= 5'h0;
      maybe_full <= 1'h0;
    end
    else begin
      if (do_enq)
        enq_ptr_value <= enq_ptr_value + 5'h1;
      if (do_deq)
        deq_ptr_value <= deq_ptr_value + 5'h1;
      if (~(do_enq == do_deq))
        maybe_full <= do_enq;
    end
  end // always @(posedge)
  ram_32x8 ram_ext (
    .R0_addr (do_deq ? ((&deq_ptr_value) ? 5'h0 : deq_ptr_value + 5'h1) : deq_ptr_value),
    .R0_en   (1'h1),
    .R0_clk  (clock),
    .R0_data (io_deq_bits),
    .W0_addr (enq_ptr_value),
    .W0_en   (do_enq),
    .W0_clk  (clock),
    .W0_data (io_enq_bits)
  );
  assign io_deq_valid = ~empty;
endmodule

module RX(
  input        clock,
               reset,
  output       io_rdy,
  input        io_en,
  output [7:0] io_data,
  input        platIo
);

  reg  [2:0]      state;
  reg  [8:0]      timerReg;
  reg  [2:0]      counterReg;
  reg  [7:0]      shiftReg;
  wire            _GEN = state == 3'h0;
  wire            _GEN_0 = timerReg == 9'h137;
  wire            _GEN_1 = state == 3'h1;
  wire            _GEN_2 = state == 3'h2;
  wire            _GEN_3 = state == 3'h3;
  wire            _GEN_4 = state == 3'h4;
  wire            _GEN_5 = _GEN_4 & _GEN_0;
  wire            _GEN_6 = _GEN | _GEN_1 | _GEN_2 | _GEN_3;
  wire            _GEN_7 = _GEN_2 & _GEN_0;
  wire            _GEN_8 = timerReg == 9'h9B;
  wire [7:0][8:0] _GEN_9 =
    {{timerReg},
     {timerReg},
     {timerReg},
     {_GEN_0 ? 9'h0 : timerReg + 9'h1},
     {_GEN_8 ? 9'h0 : timerReg + 9'h1},
     {_GEN_0 ? 9'h0 : timerReg + 9'h1},
     {_GEN_8 ? 9'h0 : timerReg + 9'h1},
     {platIo | _GEN_0 ? 9'h0 : timerReg + 9'h1}};
  always @(posedge clock) begin
    if (reset)
      state <= 3'h0;
    else if (_GEN) begin
      if (~platIo & _GEN_0)
        state <= 3'h1;
    end
    else if (_GEN_1) begin
      if (_GEN_8)
        state <= 3'h2;
    end
    else if (_GEN_2) begin
      if (_GEN_0 & (&counterReg))
        state <= 3'h3;
    end
    else if (_GEN_3) begin
      if (_GEN_8)
        state <= 3'h4;
    end
    else if (_GEN_5)
      state <= 3'h0;
    timerReg <= _GEN_9[state];
    if (~_GEN) begin
      if (_GEN_1) begin
        if (_GEN_8) begin
          counterReg <= 3'h1;
          shiftReg <= {shiftReg[6:0], platIo};
        end
      end
      else begin
        if (~_GEN_7 | (&counterReg)) begin
        end
        else
          counterReg <= counterReg + 3'h1;
        if (_GEN_7)
          shiftReg <= {shiftReg[6:0], platIo};
      end
    end
  end // always @(posedge)
  Queue32_UInt8 queue (
    .clock        (clock),
    .reset        (reset),
    .io_enq_valid (~_GEN_6 & _GEN_4 & _GEN_0),
    .io_enq_bits  (_GEN_6 | ~_GEN_5 ? 8'h0 : shiftReg),
    .io_deq_ready (io_en),
    .io_deq_valid (io_rdy),
    .io_deq_bits  (io_data)
  );
endmodule

module TX(
  input        clock,
               reset,
               io_valid,
  input  [7:0] io_bits,
  output       platIo
);

  wire            _queue_q_io_deq_valid;
  wire [7:0]      _queue_q_io_deq_bits;
  reg  [1:0]      state;
  reg  [8:0]      timerReg;
  reg  [2:0]      counterReg;
  reg  [7:0]      shiftReg;
  wire            _GEN = state == 2'h0;
  wire            _GEN_0 = state == 2'h1;
  wire            _GEN_1 = state == 2'h2;
  wire            _GEN_2 = timerReg == 9'h137;
  wire [3:0][1:0] _GEN_3 =
    {{(&state) & _GEN_2 ? 2'h0 : state},
     {_GEN_2 & (&counterReg) ? 2'h3 : state},
     {_GEN_2 ? 2'h2 : state},
     {_queue_q_io_deq_valid ? 2'h1 : state}};
  wire [3:0][8:0] _GEN_4 =
    {{timerReg + 9'h1},
     {_GEN_2 ? 9'h0 : timerReg + 9'h1},
     {_GEN_2 ? 9'h0 : timerReg + 9'h1},
     {_queue_q_io_deq_valid ? 9'h0 : timerReg}};
  wire            _GEN_5 = _GEN_1 & _GEN_2;
  always @(posedge clock) begin
    if (reset)
      state <= 2'h0;
    else
      state <= _GEN_3[state];
    timerReg <= _GEN_4[state];
    if (_GEN) begin
      if (_queue_q_io_deq_valid)
        shiftReg <= _queue_q_io_deq_bits;
    end
    else begin
      if (_GEN_0) begin
        if (_GEN_2)
          counterReg <= 3'h0;
      end
      else if (~_GEN_5 | (&counterReg)) begin
      end
      else
        counterReg <= counterReg + 3'h1;
      if (_GEN_0 | ~_GEN_5 | (&counterReg)) begin
      end
      else
        shiftReg <= {shiftReg[6:0], 1'h0};
    end
  end // always @(posedge)
  Queue32_UInt8 queue_q (
    .clock        (clock),
    .reset        (reset),
    .io_enq_valid (io_valid),
    .io_enq_bits  (io_bits),
    .io_deq_ready (_GEN & _queue_q_io_deq_valid),
    .io_deq_valid (_queue_q_io_deq_valid),
    .io_deq_bits  (_queue_q_io_deq_bits)
  );
  assign platIo = _GEN | ~_GEN_0 & (~_GEN_1 | shiftReg[7]);
endmodule

module UART(
  input        clock,
               reset,
  output       rxIo_rdy,
  input        rxIo_en,
  output [7:0] rxIo_data,
  input        txIo_valid,
  input  [7:0] txIo_bits,
  input        platIo_rx,
  output       platIo_tx
);

  RX rx (
    .clock   (clock),
    .reset   (reset),
    .io_rdy  (rxIo_rdy),
    .io_en   (rxIo_en),
    .io_data (rxIo_data),
    .platIo  (platIo_rx)
  );
  TX tx (
    .clock    (clock),
    .reset    (reset),
    .io_valid (txIo_valid),
    .io_bits  (txIo_bits),
    .platIo   (platIo_tx)
  );
endmodule

module top(
  input  clock,
         reset,
         io_rx,
  output io_tx
);

  wire       _uart_rxIo_rdy;
  wire [7:0] _uart_rxIo_data;
  UART uart (
    .clock      (clock),
    .reset      (reset),
    .rxIo_rdy   (_uart_rxIo_rdy),
    .rxIo_en    (_uart_rxIo_rdy),
    .rxIo_data  (_uart_rxIo_data),
    .txIo_valid (_uart_rxIo_rdy),
    .txIo_bits  (_uart_rxIo_rdy ? _uart_rxIo_data : 8'h0),
    .platIo_rx  (io_rx),
    .platIo_tx  (io_tx)
  );
endmodule

