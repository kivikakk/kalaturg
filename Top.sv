// Generated by CIRCT firtool-1.62.0
module RX(
  input        clock,
               reset,
  output       io_rdy,
  input        io_en,
  output [7:0] io_data,
  input        platIo
);

  reg             rdyReg;
  reg  [7:0]      dataReg;
  reg  [2:0]      state;
  reg  [8:0]      timerReg;
  reg  [2:0]      counterReg;
  reg  [7:0]      shiftReg;
  wire            _GEN = state == 3'h3;
  wire            _GEN_0 = state == 3'h0;
  wire            _GEN_1 = timerReg == 9'h137;
  wire            _GEN_2 = state == 3'h1;
  wire            _GEN_3 = timerReg == 9'h9B;
  wire            _GEN_4 = state == 3'h2;
  wire            _GEN_5 = state == 3'h4 & _GEN_1;
  wire            _GEN_6 = _GEN_0 | _GEN_2 | _GEN_4 | _GEN;
  wire [7:0][8:0] _GEN_7 =
    {{timerReg},
     {timerReg},
     {timerReg},
     {_GEN_1 ? 9'h0 : timerReg + 9'h1},
     {_GEN_3 ? 9'h0 : timerReg + 9'h1},
     {_GEN_1 ? 9'h0 : timerReg + 9'h1},
     {_GEN_3 ? 9'h0 : timerReg + 9'h1},
     {platIo | _GEN_1 ? 9'h0 : timerReg + 9'h1}};
  wire            _GEN_8 = _GEN_4 & _GEN_1;
  always @(posedge clock) begin
    if (reset) begin
      rdyReg <= 1'h0;
      dataReg <= 8'h0;
      state <= 3'h0;
    end
    else begin
      rdyReg <= ~io_en & (~_GEN_6 & _GEN_5 | rdyReg);
      if (_GEN_6 | ~_GEN_5) begin
      end
      else
        dataReg <= shiftReg;
      if (_GEN_0) begin
        if (~platIo & _GEN_1)
          state <= 3'h1;
      end
      else if (_GEN_2) begin
        if (_GEN_3)
          state <= 3'h2;
      end
      else if (_GEN_4) begin
        if (_GEN_1 & (&counterReg))
          state <= 3'h3;
      end
      else if (_GEN) begin
        if (_GEN_3)
          state <= 3'h4;
      end
      else if (_GEN_5)
        state <= 3'h0;
    end
    timerReg <= _GEN_7[state];
    if (~_GEN_0) begin
      if (_GEN_2) begin
        if (_GEN_3) begin
          counterReg <= 3'h1;
          shiftReg <= {shiftReg[6:0], platIo};
        end
      end
      else begin
        if (~_GEN_8 | (&counterReg)) begin
        end
        else
          counterReg <= counterReg + 3'h1;
        if (_GEN_8)
          shiftReg <= {shiftReg[6:0], platIo};
      end
    end
  end // always @(posedge)
  assign io_rdy = rdyReg;
  assign io_data = dataReg;
endmodule

module TX(
  input        clock,
               reset,
  input  [7:0] io_data,
  input        io_en,
  output       platIo
);

  reg  [1:0]      state;
  reg  [8:0]      timerReg;
  reg  [2:0]      counterReg;
  reg  [7:0]      shiftReg;
  wire            _GEN = state == 2'h0;
  wire            _GEN_0 = state == 2'h1;
  wire            _GEN_1 = state == 2'h2;
  wire            _GEN_2 = timerReg == 9'h137;
  wire [3:0][1:0] _GEN_3 =
    {{(&state) & _GEN_2 ? 2'h0 : state},
     {_GEN_2 & (&counterReg) ? 2'h3 : state},
     {_GEN_2 ? 2'h2 : state},
     {io_en ? 2'h1 : state}};
  wire [3:0][8:0] _GEN_4 =
    {{timerReg + 9'h1},
     {_GEN_2 ? 9'h0 : timerReg + 9'h1},
     {_GEN_2 ? 9'h0 : timerReg + 9'h1},
     {io_en ? 9'h0 : timerReg}};
  wire            _GEN_5 = _GEN_1 & _GEN_2;
  always @(posedge clock) begin
    if (reset)
      state <= 2'h0;
    else
      state <= _GEN_3[state];
    timerReg <= _GEN_4[state];
    if (_GEN) begin
      if (io_en)
        shiftReg <= io_data;
    end
    else begin
      if (_GEN_0) begin
        if (_GEN_2)
          counterReg <= 3'h0;
      end
      else if (~_GEN_5 | (&counterReg)) begin
      end
      else
        counterReg <= counterReg + 3'h1;
      if (_GEN_0 | ~_GEN_5 | (&counterReg)) begin
      end
      else
        shiftReg <= {shiftReg[6:0], 1'h0};
    end
  end // always @(posedge)
  assign platIo = _GEN | ~_GEN_0 & (~_GEN_1 | shiftReg[7]);
endmodule

module UART(
  input        clock,
               reset,
  output       rxIo_rdy,
  input        rxIo_en,
  output [7:0] rxIo_data,
  input  [7:0] txIo_data,
  input        txIo_en,
               platIo_rx,
  output       platIo_tx
);

  RX rx (
    .clock   (clock),
    .reset   (reset),
    .io_rdy  (rxIo_rdy),
    .io_en   (rxIo_en),
    .io_data (rxIo_data),
    .platIo  (platIo_rx)
  );
  TX tx (
    .clock   (clock),
    .reset   (reset),
    .io_data (txIo_data),
    .io_en   (txIo_en),
    .platIo  (platIo_tx)
  );
endmodule

module top(
  input  clock,
         reset,
         io_rx,
  output io_tx
);

  wire       _uart_rxIo_rdy;
  wire [7:0] _uart_rxIo_data;
  UART uart (
    .clock     (clock),
    .reset     (reset),
    .rxIo_rdy  (_uart_rxIo_rdy),
    .rxIo_en   (_uart_rxIo_rdy),
    .rxIo_data (_uart_rxIo_data),
    .txIo_data (_uart_rxIo_rdy ? _uart_rxIo_data : 8'h0),
    .txIo_en   (_uart_rxIo_rdy),
    .platIo_rx (io_rx),
    .platIo_tx (io_tx)
  );
endmodule

